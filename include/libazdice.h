#ifndef libazdice
#define libazdice

// This file is autogenerated by cbindgen. Be gentle with it ;)

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * A structure representing a value and frequency.
 * It exists as a tidier way of using a direct array.
 */
typedef struct XY
{
    /**
     * A value representing the numerical value of a dice roll.
     */
    int64_t value;
    /**
     * The number of times a value was rolled.
     */
    uint64_t frequency;
} XY;

/**
 * A probability distribution generated from a parsed `DiceBag`. X and Y values are seperate.
 */
typedef struct Distribution
{
    /**
     * A list of `XY` values. Value of roll and Frequency of how often it came up.
     */
    const struct XY *rolls_and_frequency;
    /**
     * Count of X-Values.
     */
    uint64_t count;
    /**
     * Length of the input string.
     */
    uint64_t len_input;
    /**
     * The original imput string.
     */
    const char *input;
} Distribution;

/**
 * A wrapper that shows whether the `Distribution` has been returned succesfully.
 */
typedef struct DistributionResult
{
    /**
     * A pointer to a resulting `Distribution`.
     */
    struct Distribution *succ;
    /**
     * A pointer to an error string.
     */
    const char *err;
} DistributionResult;

/**
 * This structure returns a list of results in a mostly human readable format.
 */
typedef struct Rolls
{
    /**
     * Length of the input string.
     */
    uint64_t len_input;
    /**
     * The original imput string.
     */
    const char *input;
    /**
     * The length of the result vector.
     */
    uint64_t len_dice_groups;
    /**
     * The actual results.
     */
    const int64_t *groups;
    /**
     * the results from a bonus.
     */
    int64_t bonus;
    /**
     * The grand total.
     */
    int64_t total;
} Rolls;

/**
 * Just in case we need to return lots of results.
 */
typedef struct ListRolls
{
    /**
     * The number of entries in the list.
     */
    uint64_t len;
    /**
     * A pointer to the detailed results (`Roll`s).
     */
    const struct Rolls *results;
} ListRolls;

/**
 * Basically a result. Which allows the error string to be returned if necessary.
 */
typedef struct ResultListRolls
{
    /**
     * A pointer to a structure containing a list of roll results (`ListRolls`).
     */
    const struct ListRolls *succ;
    /**
     * A pointer to an error string.
     */
    const char *err;
} ResultListRolls;

/**
 * Basically a result. Which allows the error string to be returned if necessary.
 */
typedef struct SingleRollResult
{
    /**
     * A value representing the numerical value of a dice roll.
     */
    int64_t roll;
    /**
     * A pointer to an error string.
     */
    const char *err;
} SingleRollResult;

/**
 * A wrapper around `parse::parse` + `DiceBag::make_count_distribution` for C. As arguments it
 * takes:
 *
 * `input`: the equivalent of C `char *`, (a string of bytes).
 *
 * `l`; the byte length of `input`.
 *
 * `n`: The number of rolls required. It is recommended to use at least 1,000,000 for this value.
 *
 * This function returns a `DistributionResult` containing a pointer to a `Distribution` if
 * if succesful, or a pointer to a `CString` error if it fails.
 */
struct DistributionResult parse_and_generate_distribution(const char *const *input,
                                                          uint64_t l,
                                                          uint64_t n);

/**
 * A wrapper for `parse::parse` and `DiceBag::roll`, allowing parsing a string from C and generating
 * N rolls. As arguments it takes:
 *
 * `input`: the equivalent of C `char *`, (a string of bytes).
 *
 * `l`; the byte length of `input`.
 *
 * `n`: The number of rolls required.
 *
 * This function returns a `ResultListRolls`, which either gives a complex report of subrolls
 * if succesful (pointer to `ListRolls`), or a pointer to an error string otherwise.
 *
 * NB: This function is fairly dangerous as it can fail if the input from C/C++ cannot be
 * expressed as a rust String, but what's a dice roller without a little risk?
 */
struct ResultListRolls parse_and_roll_n_times(const char *const *input,
                                              uint64_t l,
                                              uint64_t n);

/**
 * A wrapper for `parse::parse` and `DiceBag::roll`, allowing parsing a string from C and generating
 * a single roll. As arguments it takes:
 *
 * `input`: the equivalent of C `char *`, (a string of bytes).
 *
 * This function returns a `SingleRollResult`, with a `i64` (`long int`) regardless of success or
 * failure. Importantly a pointer to `CString` indicates an error, allowing errors to be
 * examined by the caller.
 *
 * NB: This function is fairly dangerous as it can fail if the input from C/C++ cannot be
 * expressed as a rust String, but what's a dice roller without a little risk?
 */
struct SingleRollResult parse_and_roll(const char *const *input);

/**
 * A wrapper for `parse::parse` and `DiceBag::roll`, allowing parsing a string from C and generating
 * a single roll. As arguments it takes:
 *
 * `input`: the equivalent of C `char *`, (a string of bytes).
 *
 * This function returns a `i64` (`long int`), and will crash the thread upon failure.
 *
 * NB: This function is fairly dangerous as it can fail if the input from C/C++ cannot be
 * expressed as a rust String, but what's a dice roller without a little risk?
 */
int64_t parse_and_roll2(const char *const *input);

/**
 * A test function for crossing ffi.
 */
const char *test(int64_t i);

/**
 * Another test function for crossing ffi.
 */
int64_t test2(const char *const *i);

#endif /* libazdice */
